
Using xcb to create window and catch keyboard input

=includes
-#include <xcb/xcb.h>
-#include <xcb/xcb_atom.h>
-#include <xcb/xcb_icccm.h>
-#include <xcb/xcb_aux.h>
-#include <xcb/xcb_keysyms.h>
-#include <xcb/xkb.h>

-#include <X11/keysym.h>
-#include <X11/Xlib-xcb.h>
-#include <X11/XKBlib.h>


Helper function to resolve atom by name.

=xwindow
-static xcb_atom_t xcb_atom_get(xcb_connection_t *c,char *name) {
-	xcb_intern_atom_cookie_t cookie=xcb_intern_atom(c,0,strlen(name),name);
-	xcb_intern_atom_reply_t *reply=xcb_intern_atom_reply(c,cookie,NULL);
-	if(!reply) return XCB_NONE;
-	return reply->atom;
-}

Make tiny window.

=xwindow
-static xcb_connection_t    *c;
-void make_window() {
-	Display *dpy=XOpenDisplay(NULL);
-	c=XGetXCBConnection(dpy);
-	xcb_screen_t *s=xcb_setup_roots_iterator(xcb_get_setup(c)).data;
-	xcb_window_t w=xcb_generate_id(c);
-	uint32_t mv[]={s->black_pixel,XCB_EVENT_MASK_KEY_PRESS|XCB_EVENT_MASK_KEY_RELEASE|XCB_EVENT_MASK_FOCUS_CHANGE};
-	xcb_create_window(c,s->root_depth,w,s->root,
-		10,10,10,10,1,XCB_WINDOW_CLASS_INPUT_OUTPUT,s->root_visual,
-		XCB_CW_BACK_PIXEL|XCB_CW_EVENT_MASK,mv);
-	xcb_icccm_set_wm_transient_for(c,w,w);
-	xcb_change_property(c,XCB_PROP_MODE_REPLACE,w,xcb_atom_get(c, "WM_CLASS"),XCB_ATOM_STRING,8,14,"keys\0keys");
-	xcb_map_window(c, w);
-	xcb_flush(c);

Xwindow is a big pile of mess so here is a bit of magic
to turn off (somewhat) key autorepeat:

	xcb_xkb_per_client_flags_cookie_t cookie=xcb_xkb_per_client_flags_unchecked(c,XCB_XKB_ID_USE_CORE_KBD,XCB_XKB_PER_CLIENT_FLAG_DETECTABLE_AUTO_REPEAT,XCB_XKB_PER_CLIENT_FLAG_DETECTABLE_AUTO_REPEAT,0,0,0);
	xcb_xkb_per_client_flags_reply(c,cookie,0);

But this does not work as XCB is pretty unfinished now and
there is no xkb library (but headers are here). Instead
we use X11-xlib compability layer.

-	XkbSetDetectableAutoRepeat(dpy,True,0);
-}

Read keys

=xwindow
-void event_loop() {
-	xcb_generic_event_t *e;
-	for(;;) {
-		while ((e=xcb_wait_for_event(c))) {
-			switch (e->response_type & ~0x80) {
-			case XCB_KEY_RELEASE: {
-					xcb_key_press_event_t *ke=(xcb_key_press_event_t*)e;
-					xcb_key_symbols_t *sm=xcb_key_symbols_alloc(c);
-					xcb_keysym_t k=xcb_key_press_lookup_keysym (sm,ke,0);
-					xcb_key_symbols_free(sm);
-					key(k,0,ke->time);
-				}
-			break;
-			case XCB_KEY_PRESS: {
-					open_jack();
-					xcb_key_press_event_t *ke=(xcb_key_press_event_t*)e;
-					xcb_key_symbols_t *sm=xcb_key_symbols_alloc(c);
-					xcb_keysym_t k=xcb_key_press_lookup_keysym (sm,ke,0);
-					xcb_key_symbols_free(sm);
-					key(k,1,ke->time);
-				}
-			break;
-			case XCB_FOCUS_IN: open_jack(); break;
-			case XCB_FOCUS_OUT: close_jack(); break;
-			}
-		}
-	}
-}

=keyboard
-static int keys[256];
-void key(unsigned int k,int v, int t) {
-	if(k>255) return;

When key is not already pressed, handle press.

-	if(!keys[k] && v) press(k,keys[0x20]);

If key is released, release.

-	else if(!v) release(k);
-
-	keys[k]=v;
-	
-}


Sound is played through four generators. Start parameter
is when gen started in frames since beginning. Period is in
frames. If start is zero, then gen is not running.

=sound
-long long frame=0;

-struct gen {
-	int start;
-	int end;
-	int key;
-	float period;
-	float lp;
-} gen[4]={{0},{0},{0},{0}};

Generate key to frequency map:

=sound
-float chart[256];

-void make_freq_chart() {
-	memset(chart,0,sizeof(chart));
-	//        "CcDdEFfGgAaBCcDdEFfGgAaBCcDdEFfGgAaBCcDdEFfGgAaBCcDdEFfGgAaBCcDdEFfGgAaB
-	char *keys="zsxdcvgbhnjmq2w3er5t6y7ui9o0p[=]";
-	char *p;
-	int i=0; for(p=keys;*p;p++) {
-		chart[(int)*p]=261.626*pow(2,i++/12.0)+drand48()/1000.0;
-	}
-}



When pressed start generator

=sound
-static struct gen *getgen() {
-	int i; for(i=0;i<4;i++) { if(gen[i].start==0) return &gen[i]; }
-	return 0;
-}

-static struct gen *getgenbyk(int k) {
-	int i; for(i=0;i<4;i++) { if(gen[i].key==k) return &gen[i]; }
-	return 0;
-}

-void press(int k,int shift) {
-	struct gen *g=getgenbyk(k);
-	if(!g) g=getgen();
-	if(!g) return;
-	float ck=chart[k];
-	if(ck==0) return;
-	if(shift) ck/=2;
-	g->period=48000/ck;
-	g->key=k;
-	g->start=frame;
-	g->end=0;
-}

-void release(int k) {
-	struct gen *g=getgenbyk(k);
-	if(g) { g->end=frame; }
-}

=includes
-#include <jack/jack.h>


=sound
-jack_port_t *o;
-
-int process (jack_nframes_t nframes, void *arg) {
-	jack_default_audio_sample_t *os=(jack_default_audio_sample_t*)jack_port_get_buffer(o,nframes);
-
-	int i;
-	for(i=0;i<nframes;i++) {
-		os[i]=0;
-		int j; for(j=0;j<4;j++) {
-			struct gen *g=&gen[j];
-			if(!g->start) continue;
-			int d=frame-g->start;
-			float v=(((int)(d/g->period))&1)?0.1:-0.1;
-			if(g->end) {
-				int d=frame-g->end;
-				float k=1.0-(d/4800.0);
-				if(k<0) { k=0; g->start=0; }
-				v*=k;
-			}
-			float a=0.1;
-			v=v*a + (1-a)*g->lp;
-			g->lp=v;

-			os[i]+=v;
-		}

Metronome 100ms tick

-#if 0
-		int d=frame%48000;
-		if(d<4800) {
-			os[i]+=0.1*(1-d/4800.0);
-		}
-#endif

-		frame++;
-	}
-
-	return 0;      
-}
-
-int srate (jack_nframes_t nframes, void *arg) {
-	printf ("the sample rate is now %u/sec\n",(int)nframes);
-	return 0;
-}


We open jack only when needed

=sound
-jack_client_t *jc=0;

-void open_jack() {
-	if(jc) return;
-	jc=jack_client_open("keys",JackNoStartServer,0);
-
-	jack_set_process_callback(jc,process,0);
-	jack_set_sample_rate_callback(jc,srate,0);
-	o=jack_port_register(jc,"out",JACK_DEFAULT_AUDIO_TYPE,JackPortIsOutput,0);
-	jack_activate(jc);
-
-	jack_connect(jc,jack_port_name(o),"system:playback_1");
-	jack_connect(jc,jack_port_name(o),"system:playback_2");
-
-}

And close it when not needed.

=sound
-void close_jack() {
-	if(!jc) return;
-	printf("closing\n");
-	jack_client_close(jc);
-	jc=0;
-}


=>keys.c
>includes

-#include <math.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdint.h>
-#include <stdlib.h>

>sound
>keyboard
>xwindow

-int main() {
-	make_window();
-	make_freq_chart();
-	event_loop();
-	return 0;
-}


